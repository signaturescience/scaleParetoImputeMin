% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/step_impute_maximum.R
\name{step_impute_maximum}
\alias{step_impute_maximum}
\alias{tidy.step_impute_maximum}
\title{Impute numeric data using the maximum (or factor * maximum)}
\usage{
step_impute_maximum(
  recipe,
  ...,
  role = NA,
  trained = FALSE,
  maximums = NULL,
  factor = 1,
  skip = FALSE,
  id = recipes::rand_id("impute_maximum")
)

\method{tidy}{step_impute_maximum}(x, ...)
}
\arguments{
\item{recipe}{A recipe object. The step will be added to the sequence
of operations for this recipe.}

\item{...}{One or more selector functions to choose variables for this step.}

\item{role}{Not used by this step since no new variables are created.}

\item{trained}{A logical to indicate if the quantities for preprocessing have
been estimated.}

\item{maximums}{A named numeric vector of maximums. This is \code{NULL} until
computed by \code{\link[=prep]{prep()}}. Note that, if the original data are integers,
the maximum will be converted to an integer to maintain the same data type.}

\item{factor}{A numeric value greater than or equal to 1 to scale the maximum
values. To replace values with the double-maximum, set this argument to 2.
Default value of 1.}

\item{skip}{A logical. Should the step be skipped when the recipe is baked by
bake()? While all operations are baked when prep() is run, some operations
may not be able to be conducted on new data (e.g. processing the outcome
variable(s)). Care should be taken when using skip = TRUE as it may affect
the computations for subsequent operations.}

\item{id}{A character string that is unique to this step to identify it.}

\item{x}{A \code{step_impute_maximum} object.}
}
\description{
\code{step_impute_maximum()} creates a \emph{specification} of a recipe step that will
substitute missing values of numeric variables by the training set maximum of
those variables.
}
\details{
\code{step_impute_maximum} estimates the variable maximums from the data
used in the \code{training} argument of \code{prep.recipe}. \code{bake.recipe} then applies
the new values to new data sets using these maximums.
}
\section{Tidying}{
When you \code{\link[=tidy.recipe]{tidy()}} this step, a tibble with
columns \code{terms} (the selectors or variables selected) and \code{model}
(the maximum value) is returned.
}

\examples{
\dontshow{if (rlang::is_installed("modeldata")) (if (getRversion() >= "3.4") withAutoprint else force)(\{ # examplesIf}
data("credit_data", package = "modeldata")

## missing data per column
vapply(credit_data, function(x) mean(is.na(x)), c(num = 0))

set.seed(342)
in_training <- sample(1:nrow(credit_data), 2000)

credit_tr <- credit_data[in_training, ]
credit_te <- credit_data[-in_training, ]
missing_examples <- c(933, 1042, 1671, 1796)
library(recipes)
rec <- recipe(Price ~ ., data = credit_tr)

impute_rec <- rec \%>\%
  step_impute_maximum(Income, Assets, Debt)

imp_models <- prep(impute_rec, training = credit_tr)

imputed_te <- bake(imp_models, new_data = credit_te, everything())

credit_te[missing_examples, ]
imputed_te[missing_examples, names(credit_te)]

tidy(impute_rec, number = 1)
tidy(imp_models, number = 1)
\dontshow{\}) # examplesIf}
}
